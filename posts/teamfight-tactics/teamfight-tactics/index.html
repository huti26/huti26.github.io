<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Monte-Carlo-Simulation for Teamfight Tactics with a Flask Backend and automatic Heroku deployment | Hutan Baghery Moghaddam</title><meta name=keywords content="Python,Flask,Heroku,Teamfight Tactics"><meta name=description content="Teamfight Tactics is a statistics-based video game by Riot Games. Probabilities for complex scenarios are hard to approximate, therefore I created a simulation-based solution to help players make decisions."><meta name=author content="Hutan Baghery Moghaddam"><link rel=canonical href=https://huti26.github.io/posts/teamfight-tactics/teamfight-tactics/><link crossorigin=anonymous href=../../../assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../../assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://huti26.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://huti26.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://huti26.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://huti26.github.io/apple-touch-icon.png><link rel=mask-icon href=https://huti26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Monte-Carlo-Simulation for Teamfight Tactics with a Flask Backend and automatic Heroku deployment"><meta property="og:description" content="Teamfight Tactics is a statistics-based video game by Riot Games. Probabilities for complex scenarios are hard to approximate, therefore I created a simulation-based solution to help players make decisions."><meta property="og:type" content="article"><meta property="og:url" content="https://huti26.github.io/posts/teamfight-tactics/teamfight-tactics/"><meta property="og:image" content="https://huti26.github.io/tft-website.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-12T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-12T00:00:00+00:00"><meta property="og:site_name" content="Hutan Baghery Moghaddam"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://huti26.github.io/tft-website.png"><meta name=twitter:title content="Monte-Carlo-Simulation for Teamfight Tactics with a Flask Backend and automatic Heroku deployment"><meta name=twitter:description content="Teamfight Tactics is a statistics-based video game by Riot Games. Probabilities for complex scenarios are hard to approximate, therefore I created a simulation-based solution to help players make decisions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://huti26.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Monte-Carlo-Simulation for Teamfight Tactics with a Flask Backend and automatic Heroku deployment","item":"https://huti26.github.io/posts/teamfight-tactics/teamfight-tactics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Monte-Carlo-Simulation for Teamfight Tactics with a Flask Backend and automatic Heroku deployment","name":"Monte-Carlo-Simulation for Teamfight Tactics with a Flask Backend and automatic Heroku deployment","description":"Teamfight Tactics is a statistics-based video game by Riot Games. Probabilities for complex scenarios are hard to approximate, therefore I created a simulation-based solution to help players make decisions.","keywords":["Python","Flask","Heroku","Teamfight Tactics"],"articleBody":"Preface This preface is for people who don’t know Teamfight Tactics.\nTeamfight Tactics is a board game, in which you buy champions from a shop and place them on the board. There are 5 different tiers of champions: common, uncommon, rare, epic, and legendary. The champions of each tier cost 1, 2, 3, 4, and 5 gold respectively. With your board, you fight other people and the loser of the fight loses Health Points. Everyone starts with 100 Health Points and the last player to live wins.\nEconomy is a key aspect of TFT. You start with 0 gold, but you gain gold for a variety of reasons. To upgrade your board you have to invest that gold. You can spend gold to level up, which does two things:\nIt increases the number of champions you can place on your board. It improves your chances to hit champions of higher tiers. Additionally, you can reroll the champions offered in the shop. This costs you 2 gold and gives you 5 new champions to buy. Often, players will save up a bunch of gold and then invest it all at once, with the intention to roll specific champions. We are trying to simulate this kind of scenario with our code.\nIt is to be noted, that there is a limited amount of champions available. For example, all legendary units only exist 10 times. So if other players already bought your desired legendary 5 times, your chance of finding it is halved.\nLet’s conclude this introduction with a screenshot of what Teamfight Tactics looks like during a game.\nIn the bottom middle, you can see the shop, where currently 4 champions are offered, as the fifth one has been bought already. On top of the shop, you can see, that the player currently has 10 gold. On the very right side, you can see the Health Points remaining for each player. There are many more aspects to Teamfight Tactics, but they are not required for an understanding of this article. Regardless, I highly suggest you try playing the game!\nWhat are we trying to create Often in Teamfight Tactics players will do something called a roll down. The players will try improve their board state by investing a certain amount of gold. We are creating two different solutions here to help players make decisions.\nOne is called Calculator. The name stems from the fact, that we use precise Math to calculate the probability for a specific scenario. In this scenario the player is looking for at least one copy of a single champion while rolling down and nothing else. This actually occurs very frequently and is useful. The Calculator looks as follows.\nThe player inserts his level, gold and the tier of the champion he is trying to hit. Addtionally, he can add how many times his desired champion has already been bought by others and how many champions of the same tier have already been picked already. The player can test with the last two values, wheter he should let himself get influenced by other players potentially buying the champion before he does it or not. Also, there is a dragon toggle. Dragons are part of the new Patch and twice as costy as other units, not an important detail here, but it sligthly changes the results.\nThe other one is called Simulator. The simulator approximates probabilites for more complex scenarios by using Monte-Carlo-Simulation. The Simulator looks as follows.\nJust like before the player inserts his level and gold. Now he can search for multple champions, not just a single one as before. In the green fields he can increase the amount of times he wants to get a certain champion. With the red field he can insert how many times the champion has already been bought by himself or others. With this, the player can analyse much more complex scenarios than with the Calculator.\nCode Structure .\r├── __init__.py\r├── app.py\r├── autochess\r│ ├── __init__.py\r│ ├── ac_calculator.py\r│ ├── ac_data.py\r│ ├── ac_json.py\r│ ├── ac_simulation.py\r│ ├── ac_simulation_analyzer.py\r│ └── data.ini\r├── Procfile\r├── README.md\r├── requirements.txt\r├── static\r│ ├── custom.css\r│ ├── main.js\r│ ├── plot4.png\r│ └── tft\r│ ├── TFT7_Aatrox.png\r│ └── ...\r│ └── TFT7_Zoe.png\r└── templates\r├── ac_calculator.html\r├── ac_calculator_explanation.html\r├── ac_home.html\r├── ac_simulator.html\r├── ac_simulator_explanation.html\r└── layout\r├── base.html\r├── footer.html\r└── navbar.html Out backend logic is inside /autochess. Autochess is the general term for games like Teamfight Tactics. Our Frontend is made with Jinja2 and everything related to that is in the /templates folder. Additional web-design components are inside /static. We also have a Procfile, which we need for deployment with Heroku, but we will see that later on.\nFrontend I am not a Webdesigner and the frontend is more of a means to an end than anything else. Of course, it should still be decently looking and functional. We achieve this by using Jinja2 templates and Bootstrap. The most important pages are the Calculator and Simulator, which we have already seen. Both pages contain form data, which the user needs to input. Additionally, we have 3 sites that contain further information on the project. These sites only contain text. If you are curious about details on the frontend, you can check out the GitHub repository linked at the end. We will focus on the backend here.\nBackend For our backend we use Flask. We define our site as follows.\n@app.route('/calculator') def calculator(): return render_template( 'ac_calculator.html' ) @app.route('/simulator') def simulator(): return render_template( 'ac_simulator.html', game_data=tft_game_data ) @app.route('/api/tft/simulation', methods=['POST']) def post_tft_test(): data = request.json ... return {'chance': result} @app.route('/api/tft/calculation', methods=['POST']) def api_tft_calculation(): data = request.json ... return {'chance': result} Our user operates on the sites /calculator and /simulator. These sites then collect the data inside the forms and transmit it to the respective /api endpoints. These endpoints then process the user input and eventually return a calculated value called result.\nThis transmitting step is realized with Javascript. I rarely use Javascript, so don’t blindly copy this piece of code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 async function submitForSimulation() { let data = {}; $(\"#ac-calculate-form\") .serializeArray() .map(function (x) { data[x.name] = x.value; }); data = JSON.stringify(data); document.getElementById(\"ac-calculated-chance\").innerHTML = '\\n'; let api_address = \"https://hutan-tft-calculator.herokuapp.com/api/tft/simulation\"; if (location.hostname === \"localhost\" || location.hostname === \"127.0.0.1\") { api_address = \"http://127.0.0.1:5000/api/tft/simulation\"; } const response = await fetch(api_address, { method: \"post\", headers: { \"Content-Type\": \"application/json\" }, body: data, }); if (!response.ok) { const message = `An error has occured: ${response.status}`; throw new Error(message); } const calculatedResult = await response.json(); document.getElementById(\"ac-calculated-chance\").innerHTML = calculatedResult[\"chance\"]; return false; } At the start, we collect all fields inside our form. This is done with jquery. All our fields need to have a unique name for this to work. In rows 11-12 we insert a loading indicator, so that our users get some feedback, that a calculation is ongoing. Depending on the number of simulations, the task can take 1 or 2 seconds. In row 21 we post our collected data to the API. To guarantee, that we can use this script both during deployment and local development, we dynamically adjust the api_address before that. In row 27 we check if an error occurred. If so, we give the user feedback. If everything works as intended, we remove the loading indicator and insert the result value into the page.\nNow, we can see what happens once the data has been posted to our API endpoint. First, let’s look at the simulator.\nSimulator For our simulations, we need to maintain a board state. The initial board state is created based on the user input. This is done with ac_json.py. Our user input will look as follows.\ndata = { 'Yasuo': 1, 'Yasuo-taken': 3 } For each champion, there will be a value of how many copies the user wants and how many are already taken. We split this into two dictionaries.\nIn one, we maintain how many copies of each champion the user still wants. Whenever we buy one copy, we decrement that value from this dictionary.\nIn the second dictionary, we maintain how many copies of each champion are bought out. This is because in Teamfight Tactics there is a limited amount of copies of each champion, so buying them changes the probability of hitting another copy. So basically instead of maintaining the board state, we do the inverse and maintain the champion pool.\nOnce we have prepared our initial data, we pass it to the ACSimulationAnalyzer.\nresult = ACSimulationAnalyzer( player_level=player_level, gold=gold, desired_champ_pool=desired_champ_pool, starting_champ_pool=starting_champ_pool, n=1000, game_data=tft_game_data ).analyze() player_level, gold, desired_champ_pool, starting_champ_pool are all dependent on user input. n is the number of simulations to run and we use 1000 here. How many iterations are to be run during Monte-Carlo-Simulation is a big topic and there are entire papers on it. 1000 offers us a good balance between precision and calculation time here based on simply trying it out. The last variable is game_data. Teamfight Tactics is an ever-changing game. We have a modular design, that can deal with any kind of situation. We can reuse the same code for different sets (Yearly big overhaul of Teamfight Tactics) and different patches (Small frequent number changes). For that, we store our data inside /autochess/data.ini. Inside it, we can have the data for multiple sets and patches and dynamically change between them, if we want to. Next, let’s look at the analyze() function in ACSimulationAnalyzer.\ndef analyze(self):\rfor _ in range(self.n):\rhit_everything = ACSimulation(player_level=self.player_level,\rgold=self.gold,\rstarting_champ_pool=deepcopy(self.starting_champ_pool),\rdesired_champ_pool=deepcopy(self.desired_champ_pool),\rgame_data=self.game_data\r).start()\rif hit_everything:\rself.hits += 1\rreturn self.hits / self.n This function simply runs n simulations and checks how many were successful. Since our simulations are all independent of each other, we can easily multithread this code. We don’t do that here, as we intend to run this on a base-tier Heroku machine, which has only 1 CPU anyways.\nNow we can look at the code that simulates a roll down in Teamfight Tactics.\ndef simulate_champs_rolled(self): while self.gold \u003e= 3 and self.champs_to_hit_count \u003e 0: self.gold -= 2 for _ in range(5): # roll a tier tier = choice( options=[\"1\", \"2\", \"3\", \"4\", \"5\"], probs=self.game_data.get_probabilities_of_level(self.player_level), n=1 )[0] # roll a champ in rolled tier champ_names = list(self.champ_pool[tier].keys()) poolsizes = list(self.champ_pool[tier].values()) probabilites = [poolsize / self.champ_pool[\"sum\"][tier] for poolsize in poolsizes] rolled_champ = choice(options=champ_names, probs=probabilites, n=1)[0] rolled_champ_cost = self.game_data.champion_costs[rolled_champ] # buy it? if self.desired_champ_pool[tier][rolled_champ] \u003e 0 and self.gold \u003e= rolled_champ_cost: self.gold -= rolled_champ_cost self.desired_champ_pool[tier][rolled_champ] -= 1 self.desired_champ_pool[\"sum\"][tier] -= 1 self.champ_pool[tier][rolled_champ] -= 1 self.champ_pool[\"sum\"][tier] -= 1 self.champs_to_hit_count -= 1 We start with a while loop, that keeps going, as long as our gold is larger than 3. With 2 gold, we can start a new roll and we need at least 1 gold to buy a new unit. So if we have less than 3 gold, our simulation is finished. The second condition on which our simulation is finished is that we hit all the champions we desired. For that, we keep track of the total count of units to hit.\nInside the loop, we subtract the 2 gold required for rolling from our gold. Then we simulate refreshing the shop. We do this by repeating five times, what we defined as a throw in the beginning. A throw starts with tier selection. We randomly select one of the tiers with the choice() function. The chance of hitting each tier is dependent on the player level, which the user input provided. Then, once we have picked a tier by random, we pick one of the champions inside that tier’s champion pool. As a simple example, if there are 2 champions in a tier and there are 3 copies of champion A and 7 copies of champion B left, then we have a 30% and 70% chance to roll the champion respectively. Finally, we will check if the rolled champion is one of the champions, that our user wants. If we have enough gold to buy the unit, we do so. We then subtract the buying costs from our gold, adjust our two dictionaries and decrement the champs_to_hit_count.\nOnce our simulation is finished, we check with create_output(), if we hit all desired champions. Based on that, we return true or false.\nAnd this already concludes the important parts of our simulation.\nCalculator As mentioned, the calculator can handle one specific scenario: The player is going to do a roll down and wants at least 1 single copy of a champion. We won’t look at code here, instead, we will look at the maths, which our code reflects.\nWe will understand the general idea with an example. Imagine you are rolling for one specific Legendary on Level 7. Let’s pick Amumu here as our desired Legendary. The chance to roll a random Legendary is 2% per throw:\nP(Roll a random Legendary) = 2% The chance to roll Amumu is:\nP(Roll Amumu) = P(Roll a random Legendary) * (Amount Amumus in the pool / Amount of all Legendaries in the pool) There are 7 Legendary units as of right now. Each Legendary unit is 10 times in the Pool. So the Chance per throw to roll Amumu, assuming 0 Legendaries have been picked so far is:\nP(Roll Amumu) = 2% * (10 / 7 * 10) = 0,28% Therefore the Chance per throw to not roll Amumu is:\nP(Dont roll Amumu) = 1 - P(Roll Amumu) = 100% - 0,28% = 99,72% Assume you have 50 gold. 50 gold gives you 25 rerolls. Each reroll gives you 5 throws. That’s 125 throws in total. So the chance to not roll Amumu even once in 125 throws is:\nP(Dont roll Amumu in 125 throws) = 99,72% to the power of 125 = 70% In every other scenario, you will get at least one Amumu:\nP(Roll Amumu at least once in 125 throws) = 1 - P(Dont roll Amumu in 125 throws) = 100% - 70% = 30% So you would get at least one Amumu 30% of the time.\nNot mentioned here is that at the start we have to consider the buying cost of the desired champion too, so with 50 gold for a 5-star unit, we only get 44 gold worth of rolls.\nBut this sums up how our calculator operates. Next, let’s look at how this project was deployed with Heroku.\nHeroku Deployment To deploy our app on Heroku, you will have to register there. Then you should be able to see your dashboard. There you have to create a new app. Give it a name and click create. Now we want to turn this into a Python app, so go to Settings -\u003e Add buildpack and select Python. Now all that’s left to do is creating two files:\nrequirements.txt Procfile With requirements.txt we determine which packages are required to build our project. Heroku needs to know this. There are many ways to create requirements.txt, if you use an IDE like PyCharm, there is probably a function built-in already. If you like cli, you can use the following command\npip3 freeze \u003e requirements.txt Now the Procfile. Here we insert information that is specific to Heroku. In this case, it is very simple, we just insert the command to run our project. This looks as follows.\nweb: gunicorn app:app We deploy a web-type application and our deployment server is gunicorn. Many people make the mistake of using the built-in server of Flask for deployment, which the developers strictly tell us not to do, whenever we use it locally for testing.\nFinally, to automatically deploy our application, whenever we make any changes to it go to Deploy and connect your app to the GitHub repository you are developing in. Then you can pick the branch which you want to deploy from, as you maybe want to develop in certain branches and only push changes to deployment from time to time.\nThis brings us to the end of the article. I enjoyed building this app since I really like playing TFT. Working with Flask and Jinja2 was pretty intuitive. You can check out the codebase on GitHub.\n","wordCount":"2704","inLanguage":"en","image":"https://huti26.github.io/tft-website.png","datePublished":"2022-07-12T00:00:00Z","dateModified":"2022-07-12T00:00:00Z","author":{"@type":"Person","name":"Hutan Baghery Moghaddam"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://huti26.github.io/posts/teamfight-tactics/teamfight-tactics/"},"publisher":{"@type":"Organization","name":"Hutan Baghery Moghaddam","logo":{"@type":"ImageObject","url":"https://huti26.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://huti26.github.io/ accesskey=h title="Hutan BM (Alt + H)">Hutan BM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://huti26.github.io/links/ title=Links><span>Links</span></a></li><li><a href=https://huti26.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://huti26.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://huti26.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://huti26.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Monte-Carlo-Simulation for Teamfight Tactics with a Flask Backend and automatic Heroku deployment</h1><div class=post-description>Teamfight Tactics is a statistics-based video game by Riot Games. Probabilities for complex scenarios are hard to approximate, therefore I created a simulation-based solution to help players make decisions.</div><div class=post-meta><span title='2022-07-12 00:00:00 +0000 UTC'>July 12, 2022</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2704 words&nbsp;·&nbsp;Hutan Baghery Moghaddam</div></header><figure class=entry-cover><img loading=lazy src=https://huti26.github.io/tft-website.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#preface>Preface</a></li><li><a href=#what-are-we-trying-to-create>What are we trying to create</a></li><li><a href=#code-structure>Code Structure</a></li><li><a href=#frontend>Frontend</a></li><li><a href=#backend>Backend</a><ul><li><a href=#simulator>Simulator</a></li><li><a href=#calculator>Calculator</a></li></ul></li><li><a href=#heroku-deployment>Heroku Deployment</a></li></ul></nav></div></details></div><div class=post-content><h2 id=preface>Preface<a hidden class=anchor aria-hidden=true href=#preface>#</a></h2><p>This preface is for people who don&rsquo;t know Teamfight Tactics.</p><p>Teamfight Tactics is a board game, in which you buy champions from a shop and place them on the board. There are 5 different tiers of champions: common, uncommon, rare, epic, and legendary. The champions of each tier cost 1, 2, 3, 4, and 5 gold respectively. With your board, you fight other people and the loser of the fight loses Health Points. Everyone starts with 100 Health Points and the last player to live wins.</p><p>Economy is a key aspect of TFT. You start with 0 gold, but you gain gold for a variety of reasons. To upgrade your board you have to invest that gold. You can spend gold to level up, which does two things:</p><ol><li>It increases the number of champions you can place on your board.</li><li>It improves your chances to hit champions of higher tiers.</li></ol><p>Additionally, you can reroll the champions offered in the shop. This costs you 2 gold and gives you 5 new champions to buy. Often, players will save up a bunch of gold and then invest it all at once, with the intention to roll specific champions. We are trying to simulate this kind of scenario with our code.</p><p>It is to be noted, that there is a limited amount of champions available. For example, all legendary units only exist 10 times. So if other players already bought your desired legendary 5 times, your chance of finding it is halved.</p><p>Let&rsquo;s conclude this introduction with a screenshot of what Teamfight Tactics looks like during a game.</p><p><img loading=lazy src=../../../posts/teamfight-tactics/images/tft.jpg alt></p><p>In the bottom middle, you can see the shop, where currently 4 champions are offered, as the fifth one has been bought already. On top of the shop, you can see, that the player currently has 10 gold. On the very right side, you can see the Health Points remaining for each player. There are many more aspects to Teamfight Tactics, but they are not required for an understanding of this article. Regardless, I highly suggest you try playing the game!</p><h2 id=what-are-we-trying-to-create>What are we trying to create<a hidden class=anchor aria-hidden=true href=#what-are-we-trying-to-create>#</a></h2><p>Often in Teamfight Tactics players will do something called a roll down. The players will try improve their board state by investing a certain amount of gold. We are creating two different solutions here to help players make decisions.</p><p>One is called Calculator. The name stems from the fact, that we use precise Math to calculate the probability for a specific scenario. In this scenario the player is looking for at least one copy of a single champion while rolling down and nothing else. This actually occurs very frequently and is useful. The Calculator looks as follows.</p><p><img loading=lazy src=../../../posts/teamfight-tactics/images/calculator.png alt></p><p>The player inserts his level, gold and the tier of the champion he is trying to hit. Addtionally, he can add how many times his desired champion has already been bought by others and how many champions of the same tier have already been picked already. The player can test with the last two values, wheter he should let himself get influenced by other players potentially buying the champion before he does it or not. Also, there is a dragon toggle. Dragons are part of the new Patch and twice as costy as other units, not an important detail here, but it sligthly changes the results.</p><p>The other one is called Simulator. The simulator approximates probabilites for more complex scenarios by using Monte-Carlo-Simulation. The Simulator looks as follows.</p><p><img loading=lazy src=../../../posts/teamfight-tactics/images/simulator.png alt></p><p>Just like before the player inserts his level and gold. Now he can search for multple champions, not just a single one as before. In the green fields he can increase the amount of times he wants to get a certain champion. With the red field he can insert how many times the champion has already been bought by himself or others. With this, the player can analyse much more complex scenarios than with the Calculator.</p><h2 id=code-structure>Code Structure<a hidden class=anchor aria-hidden=true href=#code-structure>#</a></h2><pre tabindex=0><code class=language-terminal data-lang=terminal>.
├── __init__.py
├── app.py
├── autochess
│  ├── __init__.py
│  ├── ac_calculator.py
│  ├── ac_data.py
│  ├── ac_json.py
│  ├── ac_simulation.py
│  ├── ac_simulation_analyzer.py
│  └── data.ini
├── Procfile
├── README.md
├── requirements.txt
├── static
│  ├── custom.css
│  ├── main.js
│  ├── plot4.png
│  └── tft
│     ├── TFT7_Aatrox.png
│     └── ...
│     └── TFT7_Zoe.png
└── templates
   ├── ac_calculator.html
   ├── ac_calculator_explanation.html
   ├── ac_home.html
   ├── ac_simulator.html
   ├── ac_simulator_explanation.html
   └── layout
      ├── base.html
      ├── footer.html
      └── navbar.html
</code></pre><p>Out backend logic is inside <code>/autochess</code>. Autochess is the general term for games like Teamfight Tactics. Our Frontend is made with Jinja2 and everything related to that is in the <code>/templates</code> folder. Additional web-design components are inside <code>/static</code>. We also have a <code>Procfile</code>, which we need for deployment with Heroku, but we will see that later on.</p><h2 id=frontend>Frontend<a hidden class=anchor aria-hidden=true href=#frontend>#</a></h2><p>I am not a Webdesigner and the frontend is more of a means to an end than anything else. Of course, it should still be decently looking and functional. We achieve this by using Jinja2 templates and Bootstrap. The most important pages are the Calculator and Simulator, which we have already seen. Both pages contain form data, which the user needs to input. Additionally, we have 3 sites that contain further information on the project. These sites only contain text. If you are curious about details on the frontend, you can check out the GitHub repository linked at the end. We will focus on the backend here.</p><h2 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h2><p>For our backend we use Flask. We define our site as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@app</span><span class=o>.</span><span class=n>route</span><span class=p>(</span><span class=s1>&#39;/calculator&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculator</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>render_template</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;ac_calculator.html&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app</span><span class=o>.</span><span class=n>route</span><span class=p>(</span><span class=s1>&#39;/simulator&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>simulator</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>render_template</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;ac_simulator.html&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>game_data</span><span class=o>=</span><span class=n>tft_game_data</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app</span><span class=o>.</span><span class=n>route</span><span class=p>(</span><span class=s1>&#39;/api/tft/simulation&#39;</span><span class=p>,</span> <span class=n>methods</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;POST&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>post_tft_test</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=n>json</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s1>&#39;chance&#39;</span><span class=p>:</span> <span class=n>result</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app</span><span class=o>.</span><span class=n>route</span><span class=p>(</span><span class=s1>&#39;/api/tft/calculation&#39;</span><span class=p>,</span> <span class=n>methods</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;POST&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>api_tft_calculation</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=n>json</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s1>&#39;chance&#39;</span><span class=p>:</span> <span class=n>result</span><span class=p>}</span>
</span></span></code></pre></div><p>Our user operates on the sites <code>/calculator</code> and <code>/simulator</code>. These sites then collect the data inside the forms and transmit it to the respective <code>/api</code> endpoints. These endpoints then process the user input and eventually return a calculated value called <code>result</code>.</p><p>This transmitting step is realized with Javascript. I rarely use Javascript, so don&rsquo;t blindly copy this piece of code.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>submitForSimulation</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>data</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>  <span class=nx>$</span><span class=p>(</span><span class=s2>&#34;#ac-calculate-form&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nx>serializeArray</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>data</span><span class=p>[</span><span class=nx>x</span><span class=p>.</span><span class=nx>name</span><span class=p>]</span> <span class=o>=</span> <span class=nx>x</span><span class=p>.</span><span class=nx>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>data</span> <span class=o>=</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;ac-calculated-chance&#34;</span><span class=p>).</span><span class=nx>innerHTML</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;&lt;div class=&#34;spinner-border&#34; role=&#34;status&#34; id=&#34;ac-calculated-chance&#34;&gt;&lt;/div&gt;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>api_address</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;https://hutan-tft-calculator.herokuapp.com/api/tft/simulation&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>location</span><span class=p>.</span><span class=nx>hostname</span> <span class=o>===</span> <span class=s2>&#34;localhost&#34;</span> <span class=o>||</span> <span class=nx>location</span><span class=p>.</span><span class=nx>hostname</span> <span class=o>===</span> <span class=s2>&#34;127.0.0.1&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>api_address</span> <span class=o>=</span> <span class=s2>&#34;http://127.0.0.1:5000/api/tft/simulation&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>response</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>fetch</span><span class=p>(</span><span class=nx>api_address</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>method</span><span class=o>:</span> <span class=s2>&#34;post&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>headers</span><span class=o>:</span> <span class=p>{</span> <span class=s2>&#34;Content-Type&#34;</span><span class=o>:</span> <span class=s2>&#34;application/json&#34;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>body</span><span class=o>:</span> <span class=nx>data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>response</span><span class=p>.</span><span class=nx>ok</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>message</span> <span class=o>=</span> <span class=sb>`An error has occured: </span><span class=si>${</span><span class=nx>response</span><span class=p>.</span><span class=nx>status</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>calculatedResult</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>response</span><span class=p>.</span><span class=nx>json</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;ac-calculated-chance&#34;</span><span class=p>).</span><span class=nx>innerHTML</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=nx>calculatedResult</span><span class=p>[</span><span class=s2>&#34;chance&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>At the start, we collect all fields inside our form. This is done with jquery. All our fields need to have a unique name for this to work. In rows 11-12 we insert a loading indicator, so that our users get some feedback, that a calculation is ongoing. Depending on the number of simulations, the task can take 1 or 2 seconds. In row 21 we post our collected data to the API. To guarantee, that we can use this script both during deployment and local development, we dynamically adjust the <code>api_address</code> before that. In row 27 we check if an error occurred. If so, we give the user feedback. If everything works as intended, we remove the loading indicator and insert the result value into the page.</p><p>Now, we can see what happens once the data has been posted to our API endpoint. First, let&rsquo;s look at the simulator.</p><h3 id=simulator>Simulator<a hidden class=anchor aria-hidden=true href=#simulator>#</a></h3><p>For our simulations, we need to maintain a board state. The initial board state is created based on the user input. This is done with <code>ac_json.py</code>. Our user input will look as follows.</p><pre tabindex=0><code class=language-terminal data-lang=terminal>data = { &#39;Yasuo&#39;: 1, &#39;Yasuo-taken&#39;: 3 }
</code></pre><p>For each champion, there will be a value of how many copies the user wants and how many are already taken. We split this into two dictionaries.</p><p>In one, we maintain how many copies of each champion the user still wants. Whenever we buy one copy, we decrement that value from this dictionary.</p><p>In the second dictionary, we maintain how many copies of each champion are bought out. This is because in Teamfight Tactics there is a limited amount of copies of each champion, so buying them changes the probability of hitting another copy. So basically instead of maintaining the board state, we do the inverse and maintain the champion pool.</p><p>Once we have prepared our initial data, we pass it to the <code>ACSimulationAnalyzer</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>ACSimulationAnalyzer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>player_level</span><span class=o>=</span><span class=n>player_level</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>gold</span><span class=o>=</span><span class=n>gold</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>desired_champ_pool</span><span class=o>=</span><span class=n>desired_champ_pool</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>starting_champ_pool</span><span class=o>=</span><span class=n>starting_champ_pool</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span><span class=o>=</span><span class=mi>1000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>game_data</span><span class=o>=</span><span class=n>tft_game_data</span>
</span></span><span class=line><span class=cl><span class=p>)</span><span class=o>.</span><span class=n>analyze</span><span class=p>()</span>
</span></span></code></pre></div><p><code>player_level, gold, desired_champ_pool, starting_champ_pool</code> are all dependent on user input. <code>n</code> is the number of simulations to run and we use 1000 here. How many iterations are to be run during Monte-Carlo-Simulation is a big topic and there are entire papers on it. 1000 offers us a good balance between precision and calculation time here based on simply trying it out. The last variable is <code>game_data</code>. Teamfight Tactics is an ever-changing game. We have a modular design, that can deal with any kind of situation. We can reuse the same code for different sets (Yearly big overhaul of Teamfight Tactics) and different patches (Small frequent number changes). For that, we store our data inside <code>/autochess/data.ini</code>. Inside it, we can have the data for multiple sets and patches and dynamically change between them, if we want to. Next, let&rsquo;s look at the <code>analyze()</code> function in <code>ACSimulationAnalyzer</code>.</p><pre tabindex=0><code>def analyze(self):
    for _ in range(self.n):
        hit_everything = ACSimulation(player_level=self.player_level,
                                      gold=self.gold,
                                      starting_champ_pool=deepcopy(self.starting_champ_pool),
                                      desired_champ_pool=deepcopy(self.desired_champ_pool),
                                      game_data=self.game_data
                                      ).start()
        if hit_everything:
            self.hits += 1

    return self.hits / self.n
</code></pre><p>This function simply runs n simulations and checks how many were successful. Since our simulations are all independent of each other, we can easily multithread this code. We don&rsquo;t do that here, as we intend to run this on a base-tier Heroku machine, which has only 1 CPU anyways.</p><p>Now we can look at the code that simulates a roll down in Teamfight Tactics.</p><div class=highlight linesnos=true><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>simulate_champs_rolled</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>gold</span> <span class=o>&gt;=</span> <span class=mi>3</span> <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>champs_to_hit_count</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>gold</span> <span class=o>-=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># roll a tier</span>
</span></span><span class=line><span class=cl>            <span class=n>tier</span> <span class=o>=</span> <span class=n>choice</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>options</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;1&#34;</span><span class=p>,</span> <span class=s2>&#34;2&#34;</span><span class=p>,</span> <span class=s2>&#34;3&#34;</span><span class=p>,</span> <span class=s2>&#34;4&#34;</span><span class=p>,</span> <span class=s2>&#34;5&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                <span class=n>probs</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>game_data</span><span class=o>.</span><span class=n>get_probabilities_of_level</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>player_level</span><span class=p>),</span> <span class=n>n</span><span class=o>=</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># roll a champ in rolled tier</span>
</span></span><span class=line><span class=cl>            <span class=n>champ_names</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>champ_pool</span><span class=p>[</span><span class=n>tier</span><span class=p>]</span><span class=o>.</span><span class=n>keys</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=n>poolsizes</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>champ_pool</span><span class=p>[</span><span class=n>tier</span><span class=p>]</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>probabilites</span> <span class=o>=</span> <span class=p>[</span><span class=n>poolsize</span> <span class=o>/</span> <span class=bp>self</span><span class=o>.</span><span class=n>champ_pool</span><span class=p>[</span><span class=s2>&#34;sum&#34;</span><span class=p>][</span><span class=n>tier</span><span class=p>]</span> <span class=k>for</span> <span class=n>poolsize</span> <span class=ow>in</span> <span class=n>poolsizes</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>rolled_champ</span> <span class=o>=</span> <span class=n>choice</span><span class=p>(</span><span class=n>options</span><span class=o>=</span><span class=n>champ_names</span><span class=p>,</span> <span class=n>probs</span><span class=o>=</span><span class=n>probabilites</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=mi>1</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>rolled_champ_cost</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>game_data</span><span class=o>.</span><span class=n>champion_costs</span><span class=p>[</span><span class=n>rolled_champ</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># buy it?</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>desired_champ_pool</span><span class=p>[</span><span class=n>tier</span><span class=p>][</span><span class=n>rolled_champ</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>gold</span> <span class=o>&gt;=</span> <span class=n>rolled_champ_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>gold</span> <span class=o>-=</span> <span class=n>rolled_champ_cost</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>desired_champ_pool</span><span class=p>[</span><span class=n>tier</span><span class=p>][</span><span class=n>rolled_champ</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>desired_champ_pool</span><span class=p>[</span><span class=s2>&#34;sum&#34;</span><span class=p>][</span><span class=n>tier</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>champ_pool</span><span class=p>[</span><span class=n>tier</span><span class=p>][</span><span class=n>rolled_champ</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>champ_pool</span><span class=p>[</span><span class=s2>&#34;sum&#34;</span><span class=p>][</span><span class=n>tier</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>champs_to_hit_count</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span></code></pre></div><p>We start with a while loop, that keeps going, as long as our gold is larger than 3. With 2 gold, we can start a new roll and we need at least 1 gold to buy a new unit. So if we have less than 3 gold, our simulation is finished. The second condition on which our simulation is finished is that we hit all the champions we desired. For that, we keep track of the total count of units to hit.</p><p>Inside the loop, we subtract the 2 gold required for rolling from our gold. Then we simulate refreshing the shop. We do this by repeating five times, what we defined as a throw in the beginning. A throw starts with tier selection. We randomly select one of the tiers with the <code>choice()</code> function. The chance of hitting each tier is dependent on the player level, which the user input provided. Then, once we have picked a tier by random, we pick one of the champions inside that tier&rsquo;s champion pool. As a simple example, if there are 2 champions in a tier and there are 3 copies of champion A and 7 copies of champion B left, then we have a 30% and 70% chance to roll the champion respectively. Finally, we will check if the rolled champion is one of the champions, that our user wants. If we have enough gold to buy the unit, we do so. We then subtract the buying costs from our gold, adjust our two dictionaries and decrement the <code>champs_to_hit_count</code>.</p><p>Once our simulation is finished, we check with <code>create_output()</code>, if we hit all desired champions. Based on that, we return true or false.</p><p>And this already concludes the important parts of our simulation.</p><h3 id=calculator>Calculator<a hidden class=anchor aria-hidden=true href=#calculator>#</a></h3><p>As mentioned, the calculator can handle one specific scenario: The player is going to do a roll down and wants at least 1 single copy of a champion. We won&rsquo;t look at code here, instead, we will look at the maths, which our code reflects.</p><p>We will understand the general idea with an example. Imagine you are rolling for one specific Legendary on Level 7. Let&rsquo;s pick Amumu here as our desired Legendary. The chance to roll a random Legendary is 2% per throw:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>P(Roll a random Legendary) = 2%
</code></pre><p>The chance to roll Amumu is:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>P(Roll Amumu) = P(Roll a random Legendary) * (Amount Amumus in the pool / Amount of all Legendaries in the pool)
</code></pre><p>There are 7 Legendary units as of right now. Each Legendary unit is 10 times in the Pool. So the Chance per throw to roll Amumu, assuming 0 Legendaries have been picked so far is:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>P(Roll Amumu) = 2% * (10 / 7 * 10) = 0,28%
</code></pre><p>Therefore the Chance per throw to not roll Amumu is:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>P(Dont roll Amumu) = 1 - P(Roll Amumu) = 100% - 0,28% = 99,72%
</code></pre><p>Assume you have 50 gold. 50 gold gives you 25 rerolls. Each reroll gives you 5 throws. That&rsquo;s 125 throws in total. So the chance to not roll Amumu even once in 125 throws is:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>P(Dont roll Amumu in 125 throws) = 99,72% to the power of 125 = 70%
</code></pre><p>In every other scenario, you will get at least one Amumu:</p><pre tabindex=0><code class=language-terminal data-lang=terminal>P(Roll Amumu at least once in 125 throws) = 1 - P(Dont roll Amumu in 125 throws) = 100% - 70% = 30%
</code></pre><p>So you would get at least one Amumu 30% of the time.</p><p>Not mentioned here is that at the start we have to consider the buying cost of the desired champion too, so with 50 gold for a 5-star unit, we only get 44 gold worth of rolls.</p><p>But this sums up how our calculator operates. Next, let&rsquo;s look at how this project was deployed with Heroku.</p><h2 id=heroku-deployment>Heroku Deployment<a hidden class=anchor aria-hidden=true href=#heroku-deployment>#</a></h2><p>To deploy our app on Heroku, you will have to register there. Then you should be able to see your dashboard. There you have to create a new app. Give it a name and click create. Now we want to turn this into a Python app, so go to Settings -> Add buildpack and select Python. Now all that&rsquo;s left to do is creating two files:</p><ol><li>requirements.txt</li><li>Procfile</li></ol><p>With <code>requirements.txt</code> we determine which packages are required to build our project. Heroku needs to know this. There are many ways to create <code>requirements.txt</code>, if you use an IDE like PyCharm, there is probably a function built-in already. If you like cli, you can use the following command</p><pre tabindex=0><code class=language-terminal data-lang=terminal>pip3 freeze &gt; requirements.txt
</code></pre><p>Now the <code>Procfile</code>. Here we insert information that is specific to Heroku. In this case, it is very simple, we just insert the command to run our project. This looks as follows.</p><pre tabindex=0><code class=language-terminal data-lang=terminal>web: gunicorn app:app
</code></pre><p>We deploy a web-type application and our deployment server is gunicorn. Many people make the mistake of using the built-in server of Flask for deployment, which the developers strictly tell us not to do, whenever we use it locally for testing.</p><p>Finally, to automatically deploy our application, whenever we make any changes to it go to Deploy and connect your app to the GitHub repository you are developing in. Then you can pick the branch which you want to deploy from, as you maybe want to develop in certain branches and only push changes to deployment from time to time.</p><p>This brings us to the end of the article. I enjoyed building this app since I really like playing TFT. Working with Flask and Jinja2 was pretty intuitive. You can check out the codebase on <a href=https://github.com/huti26/tft-website target=_blank rel=noopener>GitHub</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://huti26.github.io/tags/python/>Python</a></li><li><a href=https://huti26.github.io/tags/flask/>Flask</a></li><li><a href=https://huti26.github.io/tags/heroku/>Heroku</a></li><li><a href=https://huti26.github.io/tags/teamfight-tactics/>Teamfight Tactics</a></li></ul><nav class=paginav><a class=next href=https://huti26.github.io/posts/distributed-rocksdb/distributed-rocksdb/><span class=title>Next »</span><br><span>Making Meta's RocksDB distributed with UCX to support Infiniband Hardware</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://huti26.github.io/>Hutan Baghery Moghaddam</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>