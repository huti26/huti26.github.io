<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Creating a Multi-Process Python Bot to serve Pixiv Images with discord.py and SQLite | Hutan Baghery Moghaddam</title><meta name=keywords content="Discord,Python,SQL,Personal Projects"><meta name=description content="Preface Discord is a popular chatting platform and there are plenty of bots available, which can entertain you and your friends. There are bots out there, that post images from for example Reddit. The bots do not post the image itself, instead, they post the link to the image, and Discord itself will embed the image into the chat. Pixiv is a Japanese platform on which artists share their creations. At the time I created this bot, embedding images from Pixiv was blocked."><meta name=author content="Hutan Baghery Moghaddam"><link rel=canonical href=https://huti26.github.io/posts/discordbot/discordbot/><link crossorigin=anonymous href=../../../assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../../assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://huti26.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://huti26.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://huti26.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://huti26.github.io/apple-touch-icon.png><link rel=mask-icon href=https://huti26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Creating a Multi-Process Python Bot to serve Pixiv Images with discord.py and SQLite"><meta property="og:description" content="Preface Discord is a popular chatting platform and there are plenty of bots available, which can entertain you and your friends. There are bots out there, that post images from for example Reddit. The bots do not post the image itself, instead, they post the link to the image, and Discord itself will embed the image into the chat. Pixiv is a Japanese platform on which artists share their creations. At the time I created this bot, embedding images from Pixiv was blocked."><meta property="og:type" content="article"><meta property="og:url" content="https://huti26.github.io/posts/discordbot/discordbot/"><meta property="og:image" content="https://huti26.github.io/discord-python-sql.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-06T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-06T00:00:00+00:00"><meta property="og:site_name" content="Hutan Baghery Moghaddam"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://huti26.github.io/discord-python-sql.png"><meta name=twitter:title content="Creating a Multi-Process Python Bot to serve Pixiv Images with discord.py and SQLite"><meta name=twitter:description content="Preface Discord is a popular chatting platform and there are plenty of bots available, which can entertain you and your friends. There are bots out there, that post images from for example Reddit. The bots do not post the image itself, instead, they post the link to the image, and Discord itself will embed the image into the chat. Pixiv is a Japanese platform on which artists share their creations. At the time I created this bot, embedding images from Pixiv was blocked."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://huti26.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Creating a Multi-Process Python Bot to serve Pixiv Images with discord.py and SQLite","item":"https://huti26.github.io/posts/discordbot/discordbot/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Creating a Multi-Process Python Bot to serve Pixiv Images with discord.py and SQLite","name":"Creating a Multi-Process Python Bot to serve Pixiv Images with discord.py and SQLite","description":"Preface Discord is a popular chatting platform and there are plenty of bots available, which can entertain you and your friends. There are bots out there, that post images from for example Reddit. The bots do not post the image itself, instead, they post the link to the image, and Discord itself will embed the image into the chat. Pixiv is a Japanese platform on which artists share their creations. At the time I created this bot, embedding images from Pixiv was blocked.","keywords":["Discord","Python","SQL","Personal Projects"],"articleBody":"Preface Discord is a popular chatting platform and there are plenty of bots available, which can entertain you and your friends. There are bots out there, that post images from for example Reddit. The bots do not post the image itself, instead, they post the link to the image, and Discord itself will embed the image into the chat. Pixiv is a Japanese platform on which artists share their creations. At the time I created this bot, embedding images from Pixiv was blocked. One could only embed posts, which does not look as good as only embedding the actual image. In the following image, you can see the proper way on top, and the not wanted way on the bottom.\nThe last time I tested, embedding images from Pixiv now works properly, so this bot is not needed anymore. Regardless, I thought I would write down this article to recapitulate my findings. The general learned experience from this project might come in handy in the future.\nCode Structure The code is available on GitHub.\n/Bot\r│ config-template.ini\r│ config.ini\r│ discord_bot.py\r│ image_fetcher.py\r│ __init__.py\r│\r├───Cogs\r│ │ README.md\r│ │\r│ ├───Resources\r│ │ admins.txt\r│ │ artist-blacklist.txt\r│ │ blacklist-nsfw.txt\r│ │ blacklist.txt\r│ │ reports.txt\r│ │\r│ └───Source\r│ general_cog.py\r│ pixiv_cog.py\r│ __init__.py\r│\r└───Pixiv\r│ README.md\r│\r├───Docs\r│ └───Images\r│ illustrations.png\r│ multiimages.png\r│\r├───Resources\r│ offsets.json\r│\r├───Source\r│ pixiv_db.py\r│ pixiv_db_initializer.py\r│ pixiv_downloader.py\r│ __init__.py\r│\r└───Tests\rtest_pixiv_db.py Our code is separated into two processes, which communicate with each other. /Bot/discord_bot.py handles our discord communication and /Bot/image_fetcher.py starts our Pixiv image downloader.\nInside /Bot/Cogs/Source is code that uses the module discord.py. This code handles the communication with the Discord API. With discord.py you can separate your Discord bot’s logic into segments, called cogs. We have a general cog, which handles typical bot commands, such as responding to a ping. Anything Pixiv related is coded inside pixiv_cog.py. Additionally, we have a /Bot/Resources folder, in which you can find various configuration files.\nCode handling communication with Pixiv is inside /Bot/Pixiv. This part of the code downloads images from Pixiv and saves them inside our database.\nDatabase Before the overall architecture, we want to look at the database. This will help with the understanding of the architecture. The database consists of 3 tables: Images, Tags, and ImageTags. Pictures on Pixiv are tagged, just like for example on Instagram. A picture of a cat might have the tags “cat” and “cute”. Our tables are created as follows.\nCREATE TABLE IF NOT EXISTS \"Images\" ( \"pixiv_image_id\" integer, \"file_path\" TEXT NOT NULL, \"safety_level\" integer NOT NULL, \"artist\" integer NOT NULL, \"total_bookmarks\" integer NOT NULL, PRIMARY KEY(\"pixiv_image_id\") ); Our Images table does not store the actual image, instead, it stores the file path. Additionally, it stores some metadata. The primary key is the pixiv_image_id.\nCREATE TABLE IF NOT EXISTS \"Tags\" ( \"tag_id\" INTEGER, \"tag\" TEXT NOT NULL UNIQUE, PRIMARY KEY(\"tag_id\") ); Separately we store our tags. Each tag is a string and has an associated primary key tag_id.\nCREATE TABLE IF NOT EXISTS \"ImageTags\" ( \"pixiv_image_id\" INTEGER, \"tag_id\" INTEGER, PRIMARY KEY(\"pixiv_image_id\",\"tag_id\") ); Finally, we have the ImageTags table which connects our Images and Tags. If for example, an image has two tags, there will also be two rows inside this table.\nRegarding performance we want our bot to have fast reads. We want to respond to our users quickly. We care a lot less about writing speed. The most common way to use this bot is to give it a hashtag and expect a random picture with that hashtag in return. To optimize for this use case, we create indexes.\nCREATE INDEX IF NOT EXISTS \"imagetags_index\" ON \"ImageTags\" ( \"tag_id\", \"pixiv_image_id\" ); CREATE INDEX IF NOT EXISTS \"tags_index\" ON \"Tags\" ( \"tag\", \"tag_id\" ); We index both our Tags and our ImageTags. To understand why let’s look at what happens when a user requests a random image with a certain hashtag. For that we look inside /Bot/Pixiv/Source/pixiv_db.py and the return_image(self, tags: list, safety_level: int) function inside it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def return_image(self, tags: list, safety_level: int): ... for _ in tags: where_condition += \"tag = ? or \" # remove last \"or \" where_condition = where_condition[:-3] query = f\"\"\" SELECT * FROM Images WHERE pixiv_image_id IN ( SELECT pixiv_image_id FROM ImageTags WHERE ImageTags.tag_id IN ( SELECT tag_id FROM Tags WHERE {where_condition} ) GROUP BY pixiv_image_id HAVING COUNT(*) \u003e= ? ) AND {safety_condition} ORDER BY RANDOM() LIMIT 1 \"\"\" tag_count = len(tags) tags.append(tag_count) tags.append(safety_level) values = tags self.cursor.execute(query, values) data = self.cursor.fetchone() if data is not None: return dict(data) else: return {} On Pixiv images are separated into SFW (Safe For Work) and NSFW (Not Safe For Work). This is indicated with a safety level of 0 or 1 respectively. Our user may insert multiple tags. To handle that we dynamically adjust our query. This is done in rows 4 to 8. It is important to note, that we do not insert our tags directly into a string in that step. That would be a security issue. Instead, we insert question marks, which then will be replaced later on by our SQL Framework. In that step, these values will be sanitized.\nNow regarding our indexes, the actual query is of interest. We have a double nested query. Let’s start with the innermost query.\nSELECT tag_id FROM Tags WHERE {where_condition} First, we have to select all tag_ids matching our string hashtags. Here our tags_index will improve the performance. Next, we use these selected tag_ids as follows.\nSELECT pixiv_image_id FROM ImageTags WHERE ImageTags.tag_id IN ( -- tag_ids we selected before, that match our hashtags ) GROUP BY pixiv_image_id HAVING COUNT(*) \u003e= ? So now we select pixiv_image_ids. These pixiv_image_ids have to be tagged with the prior filtered tag_ids. Our imagetags_index will improve performance here. Finally, our pixiv_image_ids are grouped and their count is taken into consideration. This is because the user might request images that match with multiple tags.\nSELECT * FROM Images WHERE pixiv_image_id IN ( -- pixiv_image_ids we selected before ) AND {safety_condition} ORDER BY RANDOM() LIMIT 1 In the next step, we will select these pixiv_image_ids from our Images table and return one at random. The safety condition will also be applied. Here we don’t have any indexes at play. Why? Having our data sorted by the safety condition which is either 0 or 1 seems useful here, right? Creating a normal B+ Tree-based index is bad on columns with such few values. Instead, a bitmap index would be useful here. Unfortunately, SQLite does not support bitmap indexes.\nTwo final aspects to consider here regarding indexes are the following:\nThe order of the columns in our indexes is important in SQLite. We pick tag_id, then pixiv_image_id for our imagetags_index, because we will always query for tag_id.This should apply to any SQL database in theory, but if you use a different database, make sure to read the documentation. In case you are curious about details on SQLite, here is the link. If we create our imagetags_index with only the column tag_id, it would return us the table row ids for the matching tag_ids quickly. But then we would have to find the pixiv_image_ids in another step. That’s why it is important to have both fields as part of the index. Architecture Our overall architecture looks as follows.\nIn grey, our two processes are indicated. On the left, the Image Fetcher is constantly downloading images and writing them into the database. This occurs constantly, disregarding user activity. On the right, we have user activity. Whenever a user is requesting an image with a certain hashtag, the Discordbot will read such an image from the database and respond. Additionally, the Discordbot transmits the Hashtag to the Image Fetcher. The Image Fetcher keeps track of which hashtags are popular and will favor those when requesting images.\nDownloading images is realised with pixivpy. If you are curious about the details you can check this file. As mentioned, Discord communication is realized with discord.py.\nLogging, Scheduling, and Inter-Process Communication are realized with Python’s internal libraries.\nFunctionality The bot can fetch SFW or NSFW images, with an arbitrarily amount of tags. Additionally, the users can report certain images. The admins can then either blacklist an image or the entire artist. This can come in handy if you for example an artist is uploading inappropriate art and not tagging them as NSFW. Also, you might not want to see any images related to Finland. In this case, you can completely blacklist the hashtag “Finland”. Blacklisting also deletes all images fitting that criteria from the Database. No new images fitting the blacklist will be downloaded.\nDeployment This project is deployed on my Raspberry Pi 4 with Docker and Docker-Compose. I like not having to maintain any dependencies natively on my Raspberry Pi and Docker-Compose automatically restarts the Bot, anytime I might need to restart the Raspberry Pi. Here is the Dockerfile:\nFROM python:3.8-slim WORKDIR /discordapp # Need build-essential for building wheels RUN apt-get update RUN apt-get install build-essential -y --no-install-recommends # First copy just the requirements and install them COPY requirements.txt requirements.txt RUN pip install -r requirements.txt # COPY entrypoint.sh entrypoint.sh RUN [\"chmod\", \"+x\", \"entrypoint.sh\"] # Only part that changes, do this last for maximum caching COPY ./Bot/ ./Bot/ CMD [\"./entrypoint.sh\"] It uses entrypoint.sh to start our processes.\n#!/bin/bash python3 -u ./Bot/Pixiv/Source/pixiv_db_initializer.py python3 -u ./Bot/image_fetcher.py \u0026 python3 -u ./Bot/discord_bot.py And this is then utilized by our docker-compose file.\n--- version: \"2.1\" services: discordbot: build: . image: discordbot-huti container_name: discordbot volumes: # Database - pixiv_db:/discordapp/DB/ # Offsets - pixiv_resources:/discordapp/Bot/Pixiv/Resources/ # admins, blacklisted_tags - cog_resources:/discordapp/Bot/Cogs/Resources/ restart: unless-stopped volumes: pixiv_db: pixiv_resources: cog_resources: We have separate volumes for the actual database, the resources for our Pixiv Image Fetcher, and the resources for our Cogs.\nThe dockerfile is very simple and does not make any optimizations such as removing not required build files. If you are curious about how that would work, you can check out my blog entry about my Master’s Thesis, in which I made RocksDB distributed. There I have a more complex building system.\n","wordCount":"1723","inLanguage":"en","image":"https://huti26.github.io/discord-python-sql.png","datePublished":"2022-03-06T00:00:00Z","dateModified":"2022-03-06T00:00:00Z","author":{"@type":"Person","name":"Hutan Baghery Moghaddam"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://huti26.github.io/posts/discordbot/discordbot/"},"publisher":{"@type":"Organization","name":"Hutan Baghery Moghaddam","logo":{"@type":"ImageObject","url":"https://huti26.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://huti26.github.io/ accesskey=h title="Hutan BM (Alt + H)">Hutan BM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://huti26.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://huti26.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://huti26.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://huti26.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://huti26.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Creating a Multi-Process Python Bot to serve Pixiv Images with discord.py and SQLite</h1><div class=post-meta><span title='2022-03-06 00:00:00 +0000 UTC'>March 6, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1723 words&nbsp;·&nbsp;Hutan Baghery Moghaddam</div></header><figure class=entry-cover><img loading=lazy src=https://huti26.github.io/discord-python-sql.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#preface>Preface</a></li><li><a href=#code-structure>Code Structure</a></li><li><a href=#database>Database</a></li><li><a href=#architecture>Architecture</a></li><li><a href=#functionality>Functionality</a></li><li><a href=#deployment>Deployment</a></li></ul></nav></div></details></div><div class=post-content><h2 id=preface>Preface<a hidden class=anchor aria-hidden=true href=#preface>#</a></h2><p>Discord is a popular chatting platform and there are plenty of bots available, which can entertain you and your friends. There are bots out there, that post images from for example Reddit. The bots do not post the image itself, instead, they post the link to the image, and Discord itself will embed the image into the chat. Pixiv is a Japanese platform on which artists share their creations. At the time I created this bot, embedding images from Pixiv was blocked. One could only embed posts, which does not look as good as only embedding the actual image. In the following image, you can see the proper way on top, and the not wanted way on the bottom.</p><p><img loading=lazy src=../../../posts/discordbot/images/slowpoke-example-embed.png alt></p><p>The last time I tested, embedding images from Pixiv now works properly, so this bot is not needed anymore. Regardless, I thought I would write down this article to recapitulate my findings. The general learned experience from this project might come in handy in the future.</p><h2 id=code-structure>Code Structure<a hidden class=anchor aria-hidden=true href=#code-structure>#</a></h2><p>The code is available on <a href=https://github.com/huti26/discordbot target=_blank rel=noopener>GitHub</a>.</p><pre tabindex=0><code class=language-terminal data-lang=terminal>/Bot
│   config-template.ini
│   config.ini
│   discord_bot.py
│   image_fetcher.py
│   __init__.py
│
├───Cogs
│   │   README.md
│   │
│   ├───Resources
│   │       admins.txt
│   │       artist-blacklist.txt
│   │       blacklist-nsfw.txt
│   │       blacklist.txt
│   │       reports.txt
│   │
│   └───Source
│           general_cog.py
│           pixiv_cog.py
│           __init__.py
│
└───Pixiv
    │   README.md
    │
    ├───Docs
    │   └───Images
    │           illustrations.png
    │           multiimages.png
    │
    ├───Resources
    │       offsets.json
    │
    ├───Source
    │       pixiv_db.py
    │       pixiv_db_initializer.py
    │       pixiv_downloader.py
    │       __init__.py
    │
    └───Tests
            test_pixiv_db.py
</code></pre><p>Our code is separated into two processes, which communicate with each other. <code>/Bot/discord_bot.py</code> handles our discord communication and <code>/Bot/image_fetcher.py</code> starts our Pixiv image downloader.</p><p>Inside <code>/Bot/Cogs/Source</code> is code that uses the module <code>discord.py</code>. This code handles the communication with the Discord API. With <code>discord.py</code> you can separate your Discord bot&rsquo;s logic into segments, called cogs. We have a general cog, which handles typical bot commands, such as responding to a ping. Anything Pixiv related is coded inside <code>pixiv_cog.py</code>. Additionally, we have a <code>/Bot/Resources</code> folder, in which you can find various configuration files.</p><p>Code handling communication with Pixiv is inside <code>/Bot/Pixiv</code>. This part of the code downloads images from Pixiv and saves them inside our database.</p><h2 id=database>Database<a hidden class=anchor aria-hidden=true href=#database>#</a></h2><p>Before the overall architecture, we want to look at the database. This will help with the understanding of the architecture. The database consists of 3 tables: Images, Tags, and ImageTags. Pictures on Pixiv are tagged, just like for example on Instagram. A picture of a cat might have the tags &ldquo;cat&rdquo; and &ldquo;cute&rdquo;. Our tables are created as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=s2>&#34;Images&#34;</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;pixiv_image_id&#34;</span><span class=w>  </span><span class=nb>integer</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;file_path&#34;</span><span class=w> </span><span class=nb>TEXT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;safety_level&#34;</span><span class=w>  </span><span class=nb>integer</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;artist&#34;</span><span class=w>  </span><span class=nb>integer</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;total_bookmarks&#34;</span><span class=w> </span><span class=nb>integer</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=s2>&#34;pixiv_image_id&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Our Images table does not store the actual image, instead, it stores the file path. Additionally, it stores some metadata. The primary key is the <code>pixiv_image_id</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=s2>&#34;Tags&#34;</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;tag_id&#34;</span><span class=w>  </span><span class=nb>INTEGER</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;tag&#34;</span><span class=w> </span><span class=nb>TEXT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>UNIQUE</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=s2>&#34;tag_id&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Separately we store our tags. Each tag is a string and has an associated primary key <code>tag_id</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=s2>&#34;ImageTags&#34;</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;pixiv_image_id&#34;</span><span class=w>  </span><span class=nb>INTEGER</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;tag_id&#34;</span><span class=w>          </span><span class=nb>INTEGER</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=s2>&#34;pixiv_image_id&#34;</span><span class=p>,</span><span class=s2>&#34;tag_id&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Finally, we have the ImageTags table which connects our Images and Tags. If for example, an image has two tags, there will also be two rows inside this table.</p><p>Regarding performance we want our bot to have fast reads. We want to respond to our users quickly. We care a lot less about writing speed. The most common way to use this bot is to give it a hashtag and expect a random picture with that hashtag in return. To optimize for this use case, we create indexes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=s2>&#34;imagetags_index&#34;</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=s2>&#34;ImageTags&#34;</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;tag_id&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;pixiv_image_id&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=s2>&#34;tags_index&#34;</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=s2>&#34;Tags&#34;</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;tag&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;tag_id&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>We index both our Tags and our ImageTags. To understand why let&rsquo;s look at what happens when a user requests a random image with a certain hashtag. For that we look inside <code>/Bot/Pixiv/Source/pixiv_db.py</code> and the <code>return_image(self, tags: list, safety_level: int)</code> function inside it.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>return_image</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tags</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span> <span class=n>safety_level</span><span class=p>:</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>tags</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>where_condition</span> <span class=o>+=</span> <span class=s2>&#34;tag = ? or &#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># remove last &#34;or &#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>where_condition</span> <span class=o>=</span> <span class=n>where_condition</span><span class=p>[:</span><span class=o>-</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>query</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>            SELECT *
</span></span></span><span class=line><span class=cl><span class=s2>            FROM Images
</span></span></span><span class=line><span class=cl><span class=s2>            WHERE pixiv_image_id IN (
</span></span></span><span class=line><span class=cl><span class=s2>                SELECT pixiv_image_id
</span></span></span><span class=line><span class=cl><span class=s2>                FROM ImageTags
</span></span></span><span class=line><span class=cl><span class=s2>                WHERE ImageTags.tag_id IN (
</span></span></span><span class=line><span class=cl><span class=s2>                    SELECT tag_id
</span></span></span><span class=line><span class=cl><span class=s2>                    FROM Tags
</span></span></span><span class=line><span class=cl><span class=s2>                    WHERE </span><span class=si>{</span><span class=n>where_condition</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>                )
</span></span></span><span class=line><span class=cl><span class=s2>                GROUP BY pixiv_image_id
</span></span></span><span class=line><span class=cl><span class=s2>                HAVING COUNT(*) &gt;= ?
</span></span></span><span class=line><span class=cl><span class=s2>            )
</span></span></span><span class=line><span class=cl><span class=s2>            AND </span><span class=si>{</span><span class=n>safety_condition</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>            ORDER BY RANDOM()
</span></span></span><span class=line><span class=cl><span class=s2>            LIMIT 1
</span></span></span><span class=line><span class=cl><span class=s2>            &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tag_count</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>tags</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tags</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>tag_count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tags</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>safety_level</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>values</span> <span class=o>=</span> <span class=n>tags</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>query</span><span class=p>,</span> <span class=n>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>cursor</span><span class=o>.</span><span class=n>fetchone</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>data</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>dict</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><p>On Pixiv images are separated into SFW (Safe For Work) and NSFW (Not Safe For Work). This is indicated with a safety level of 0 or 1 respectively. Our user may insert multiple tags. To handle that we dynamically adjust our query. This is done in rows 4 to 8. It is important to note, that we do not insert our tags directly into a string in that step. That would be a security issue. Instead, we insert question marks, which then will be replaced later on by our SQL Framework. In that step, these values will be sanitized.</p><p>Now regarding our indexes, the actual query is of interest. We have a double nested query. Let&rsquo;s start with the innermost query.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>tag_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>Tags</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=err>{</span><span class=n>where_condition</span><span class=err>}</span><span class=w>
</span></span></span></code></pre></div><p>First, we have to select all <code>tag_ids</code> matching our string hashtags. Here our <code>tags_index</code> will improve the performance. Next, we use these selected <code>tag_ids</code> as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>pixiv_image_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>ImageTags</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>ImageTags</span><span class=p>.</span><span class=n>tag_id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- tag_ids we selected before, that match our hashtags
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>pixiv_image_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>HAVING</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=o>?</span><span class=w>
</span></span></span></code></pre></div><p>So now we select <code>pixiv_image_ids</code>. These <code>pixiv_image_ids</code> have to be tagged with the prior filtered <code>tag_ids</code>. Our <code>imagetags_index</code> will improve performance here. Finally, our <code>pixiv_image_ids</code> are grouped and their count is taken into consideration. This is because the user might request images that match with multiple tags.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>Images</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>pixiv_image_id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- pixiv_image_ids we selected before
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>AND</span><span class=w> </span><span class=err>{</span><span class=n>safety_condition</span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>RANDOM</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span></code></pre></div><p>In the next step, we will select these <code>pixiv_image_ids</code> from our Images table and return one at random. The safety condition will also be applied. Here we don&rsquo;t have any indexes at play. Why? Having our data sorted by the safety condition which is either 0 or 1 seems useful here, right? Creating a normal B+ Tree-based index is bad on columns with such few values. Instead, a bitmap index would be useful here. Unfortunately, SQLite does not support bitmap indexes.</p><p>Two final aspects to consider here regarding indexes are the following:</p><ol><li>The order of the columns in our indexes is important in SQLite. We pick <code>tag_id</code>, then <code>pixiv_image_id</code> for our <code>imagetags_index</code>, because we will always query for <code>tag_id</code>.This should apply to any SQL database in theory, but if you use a different database, make sure to read the documentation. In case you are curious about details on SQLite, here is the <a href=https://www.sqlitetutorial.net/sqlite-index/ target=_blank rel=noopener>link</a>.</li><li>If we create our <code>imagetags_index</code> with only the column <code>tag_id</code>, it would return us the table row ids for the matching <code>tag_ids</code> quickly. But then we would have to find the <code>pixiv_image_ids</code> in another step. That&rsquo;s why it is important to have both fields as part of the index.</li></ol><h2 id=architecture>Architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h2><p>Our overall architecture looks as follows.</p><p><img loading=lazy src=../../../posts/discordbot/images/discordbot.png alt></p><p>In grey, our two processes are indicated. On the left, the Image Fetcher is constantly downloading images and writing them into the database. This occurs constantly, disregarding user activity. On the right, we have user activity. Whenever a user is requesting an image with a certain hashtag, the Discordbot will read such an image from the database and respond. Additionally, the Discordbot transmits the Hashtag to the Image Fetcher. The Image Fetcher keeps track of which hashtags are popular and will favor those when requesting images.</p><p>Downloading images is realised with <a href=https://github.com/upbit/pixivpy target=_blank rel=noopener>pixivpy</a>. If you are curious about the details you can check <a href=https://github.com/huti26/discordbot/blob/main/Bot/Pixiv/Source/pixiv_downloader.py target=_blank rel=noopener>this</a> file. As mentioned, Discord communication is realized with <a href=https://github.com/Rapptz/discord.py target=_blank rel=noopener>discord.py</a>.</p><p>Logging, Scheduling, and Inter-Process Communication are realized with Python&rsquo;s internal libraries.</p><h2 id=functionality>Functionality<a hidden class=anchor aria-hidden=true href=#functionality>#</a></h2><p>The bot can fetch SFW or NSFW images, with an arbitrarily amount of tags. Additionally, the users can report certain images. The admins can then either blacklist an image or the entire artist. This can come in handy if you for example an artist is uploading inappropriate art and not tagging them as NSFW. Also, you might not want to see any images related to Finland. In this case, you can completely blacklist the hashtag &ldquo;Finland&rdquo;. Blacklisting also deletes all images fitting that criteria from the Database. No new images fitting the blacklist will be downloaded.</p><h2 id=deployment>Deployment<a hidden class=anchor aria-hidden=true href=#deployment>#</a></h2><p>This project is deployed on my Raspberry Pi 4 with Docker and Docker-Compose. I like not having to maintain any dependencies natively on my Raspberry Pi and Docker-Compose automatically restarts the Bot, anytime I might need to restart the Raspberry Pi. Here is the Dockerfile:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> python:3.8-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /discordapp</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Need build-essential for building wheels</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get install build-essential -y --no-install-recommends<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># First copy just the requirements and install them</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> requirements.txt requirements.txt<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> pip install -r requirements.txt<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>#</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> entrypoint.sh entrypoint.sh<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=o>[</span><span class=s2>&#34;chmod&#34;</span>, <span class=s2>&#34;+x&#34;</span>, <span class=s2>&#34;entrypoint.sh&#34;</span><span class=o>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Only part that changes, do this last for maximum caching</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> ./Bot/ ./Bot/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;./entrypoint.sh&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>It uses <code>entrypoint.sh</code> to start our processes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>python3 -u ./Bot/Pixiv/Source/pixiv_db_initializer.py
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>python3 -u ./Bot/image_fetcher.py <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>python3 -u ./Bot/discord_bot.py
</span></span></code></pre></div><p>And this is then utilized by our docker-compose file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;2.1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>discordbot</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>discordbot-huti</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>discordbot</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># Database</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>pixiv_db:/discordapp/DB/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># Offsets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>pixiv_resources:/discordapp/Bot/Pixiv/Resources/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># admins, blacklisted_tags</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>cog_resources:/discordapp/Bot/Cogs/Resources/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>restart</span><span class=p>:</span><span class=w> </span><span class=l>unless-stopped</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pixiv_db</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pixiv_resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>cog_resources</span><span class=p>:</span><span class=w>
</span></span></span></code></pre></div><p>We have separate volumes for the actual database, the resources for our Pixiv Image Fetcher, and the resources for our Cogs.</p><p>The dockerfile is very simple and does not make any optimizations such as removing not required build files. If you are curious about how that would work, you can check out my blog entry about my Master&rsquo;s Thesis, in which I made RocksDB distributed. There I have a more complex building system.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://huti26.github.io/tags/discord/>Discord</a></li><li><a href=https://huti26.github.io/tags/python/>Python</a></li><li><a href=https://huti26.github.io/tags/sql/>SQL</a></li><li><a href=https://huti26.github.io/tags/personal-projects/>Personal Projects</a></li></ul><nav class=paginav><a class=prev href=https://huti26.github.io/posts/flutter-calorietracker/flutter-calorietracker/><span class=title>« Prev</span><br><span>Building a Calorietracker WebApp with Flutter and Firebase</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://huti26.github.io/>Hutan Baghery Moghaddam</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>