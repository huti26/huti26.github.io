[{"content":"Preface The 2021 season of Formula 1 is the first one I watched and I have been a fan of both Hamilton and Bottas ever since. During this season Bottas has been criticized a lot. That\u0026rsquo;s why I wanted to do a bit of data analysis on how Hamilton and Bottas compare in raw numbers. Raw numbers are not a particularly good way to make hard statements in Formula 1, since they lack a lot of context. However, the raw numbers can be used as an indicator to find outliers or general trends, which then should be further analyzed with context. Additionally, there will be some comparisons between Lewis Hamilton and Sebastian Vettel during their Championship Races in 2017 and 2018. The same comparisons will be done for the 2021 season in which Lewis Hamilton and Max Verstappen competed for the Championship.\nData Source The used data can be found on Kaggle: Formula 1 World Championship (1950 - 2022). The original data source is the Ergast Developer API. The maintainers on Kaggle provide 14 CSV files containing information about drivers, constructors, and all kinds of results. The data is built in a relational format, so it can easily be imported into a SQL database of choice. In this case, SQLite is entirely sufficient. Additionally, some transformations will be made with the Python library Pandas.\nData Engineering The source code can be found on GitHub\nInitial data transformations are done in SQL and the results are in the /data folder. Any further transformations done with Pandas are stored in the /hamilton-vs-bottas folder.\nThe first analyzed data is about the race pace. For that, the lap times of Hamilton and Bottas from 2017 to 2021 were extracted. Transformations are explained in detail for this first analysis and omitted for the others. All transformations can be found in the mentioned repository and if these steps are not of your interest, just skip ahead to the analysis.\nSELECT lap_times.raceId, lap_times.driverId, lap_times.lap, lap_times.position, lap_times.milliseconds, races.year, races.round, races.name, races.date, drivers.code, drivers.forename, drivers.surname, drivers.dob, drivers.nationality, circuits.name, circuits.country, results.statusId FROM lap_times, races, drivers, circuits, results WHERE (lap_times.driverId = 1 OR lap_times.driverId = 822) AND results.statusId = 1 AND (year \u0026gt;= 2017 AND year \u0026lt;= 2021) AND lap_times.driverId = drivers.driverId AND lap_times.raceId = races.raceId AND races.circuitId = circuits.circuitId AND results.raceId = lap_times.raceId AND results.driverId = lap_times.driverId This data contains the lap time of each lap that Hamilton and Bottas drove. To further analyze this data, it was transformed with Pandas.\nFirst, the mean race pace was created.\ndata = pd.read_csv(\u0026#34;data/lap_times_ham_vs_bot_without_dnfs.csv\u0026#34;) means = data.groupby([\u0026#34;race_name\u0026#34;, \u0026#34;circuit_name\u0026#34;, \u0026#34;year\u0026#34;, \u0026#34;code\u0026#34;])[\u0026#34;milliseconds\u0026#34;].mean().reset_index() means.to_csv(\u0026#34;hamilton-vs-bottas/racepace-means-alphabetical.csv\u0026#34;, index=False) This data is now in the long format, but we require wide format data for the next step, in which we calculate the Deltas. Delta here simply means the difference in mean race pace between the drivers.\ndata = pd.read_csv(\u0026#34;hamilton-vs-bottas/racepace-means-alphabetical.csv\u0026#34;) data = data.pivot(index=[\u0026#34;race_name\u0026#34;, \u0026#34;circuit_name\u0026#34;, \u0026#34;year\u0026#34;], columns=\u0026#34;code\u0026#34;, values=\u0026#34;milliseconds\u0026#34;).reset_index() data.to_csv(\u0026#34;hamilton-vs-bottas/racepace-means-alphabetical-wide.csv\u0026#34;, index=False) Before we calculate the Deltas, we remove the 2021 race in Belgium. This is an outlier race, that did not start due to rain.\ndata = pd.read_csv(\u0026#34;hamilton-vs-bottas/racepace-means-alphabetical-wide.csv\u0026#34;) data = data.drop(data[(data[\u0026#34;circuit_name\u0026#34;] == \u0026#34;Circuit de Spa-Francorchamps\u0026#34;) \u0026amp; (data[\u0026#34;year\u0026#34;] == 2021)].index) data.to_csv(\u0026#34;hamilton-vs-bottas/racepace-means-alphabetical-wide-without-spa-2021.csv\u0026#34;, index=False) Finally, we can calculate the Deltas.\ndata = pd.read_csv(\u0026#34;hamilton-vs-bottas/racepace-means-alphabetical-wide-without-spa-2021.csv\u0026#34;) data[\u0026#34;delta\u0026#34;] = data[\u0026#34;BOT\u0026#34;] - data[\u0026#34;HAM\u0026#34;] data.to_csv(\u0026#34;hamilton-vs-bottas/racepace-means-alphabetical-wide-without-spa-with-deltas.csv\u0026#34;, index=False) Data Analysis All visualizations are created with R and ggplot.\nRacepace Here one can see two strong outliers in 2021. Race 2 and 12 favor Bottas and Hamilton respectively. In race 2 there was a DNF, which means that one of the drivers did not finish the race in case you are not familiar with Formula 1. So next, all races containing DNFs were removed.\nOne can see, that not only did the second race of 2021 get removed but also a couple of others too. This is good because the races with DNFs skew the data. However, the outlier race 12 in 2021 was not removed. This is because race 12 of 2021 is the Belgium Grand Prix, which only ran for two laps due to rain. We remove that race too.\nFinally, we can analyze the filtered data. The years in which Bottas contested Hamilton for the Championship were 2019 and 2020. Race pace-wise Bottas was faster 10 times, while Hamilton was faster 24 times. Also, when Hamilton was faster than Bottas, he was faster by a bigger margin. Similar trends can be found in the other seasons too, although it is noteworthy, that especially in the later races of the seasons Mercedes has favored Hamilton since he was the one competing for the Championship.\nThe plots above show the performance chronologically, the races are sorted from first race to last race. In the following plot, the performance sorted by racetrack is analyzed instead.\nA particularly strong track for Hamilton is his home race, the British Grand Prix. Hamilton is unbeaten by Bottas in front of his home crowd. Spa (The Belgian Grand Prix) and Barcelona (The Spanish Grand Prix) are also unbeaten tracks for Hamilton. On the other hand, Bottas has outperformed Hamilton both on the Austrian Grand Prix and in Baku (The Azerbaijan Grand Prix). Exceptionally strong races by Bottas can be found in the 2017 Russian Grand Prix, the 2019 Italian Grand Prix, and the 2021 Turkish Grand Prix.\nDNFs DNFs are another interesting aspect to analyze. Hamilton, who is self-proclaimed blessed, is known to have very DNFs, while Bottas is known for some unlucky DNFs such as his Pitstop in Monaco in 2021.\nIn the plot, we can see, that Hamilton has DNFed twice from 2017 to 2021, while Bottas has DNFed 10 times. Noteworthy is that Bottas has DNFed every single time in the 11th race since 2019. At the time I am writing this, the 10th race of the 2022 season, the British Grand Prix, has just finished and the 11th race in Austria is around the corner. Hopefully the next time we analyze this type of data, we can say, that Bottas broke this curse.\nStandings Next, we will look at how close Bottas and Hamilton were points-wise. In grey, there will be a dotted line to indicate at which race the Championship was decided. It is important to note, that this refers to the point at which Hamilton won the Championship, Bottas has been out of the Championship race earlier than that in 2017, 2018, and 2021.\nThroughout all seasons Bottas was never ahead in points after the 5th race. Hamilton quickly built a fair margin in points and kept that throughout all the seasons, when compared with Bottas.\nPositions Next, we will move away from comparing only Hamilton and Bottas. Instead, we will look at the Championship Contenders of each year.\nIt is known, that Hamilton is particularly strong in the final phase of the Championship. First, let\u0026rsquo;s look at his title fight with Vettel in 2017 and 2018. In 2017 starting with race 12, he finished 1, 1, 1, 2, 1, 1. Then a 9th place finish was enough for him to win the Championship with two more races left. 2018 was very similar, starting with race 12 he finished 1, 2, 1, 1, 1, 1, which then allowed him to win the Championship with a 3rd and 4th place, with two more races left. During both of these Hamilton streaks, Vettel has struggled a lot. Vettel finished 2, 3, 18, 4, 19, 2 in 2017 and 2, 1, 4, 3, 3, 6 in 2018.\nThe finish of 2019 against Bottas was not as smooth 2017 and 2018. Hamilton and Bottas had a strong exchange of blows starting with race 13. Overall, Bottas still lost too many points prior to that and Hamilton won the Championship with two races left. 2020 was a very dominant season for Hamilton. The season had a couple fewer races than the others due to covid and Hamilton still concluded the Championship with three races left. This is also underlined by the mean race pace per year. In 2019 Bottas was 24 milliseconds faster on average, while Hamilton was 374 milliseconds faster on average in 2020.\nFinally, we can look at the 2021 season, which is the first season Hamilton lost since 2016. The Championship was decided in the very last race, with a really small margin. The 2021 season is the closest of all analyzed seasons. Hamilton had a very strong final phase here too. Starting with race 17, he finished 2nd twice behind Verstappen. At this point, the pressure was extremely high and Hamilton had to win the next three races, which he did.\nPitstops Formula 1 is of course a Constructors Sport. No matter how good a Driver is, if the car is not good enough, a Championship is simply not possible. Building a good car is only half the battle. During the races, the Team has to make the right calls regarding strategy and perform well during Pitstops. In the following, we will compare how much time the Championship Contenders lost or gained during their Pitstops. Each bar in the following plot represents the Delta between two Pitstops. If for example, Hamilton has a two Pitstop race and Verstappen has a three Pitstop race, there will only be two bars for that race: One for comparing Hamilton\u0026rsquo;s first Pitstop to Verstappen\u0026rsquo;s first Pitstop and another one for comparing Hamilton\u0026rsquo;s second Pitstop to Verstappens second Pitstop. Additionally, we exclude any Pitstops with Deltas larger than 4 seconds. This is done to avoid comparing a normal Pitstop in which only the tyres are changed to a Pitstop in which a damaged front wing had to be replaced.\nIn 2017 and 2018 the results are fairly close in terms of how often each driver gained an advantage. Vettel gained time 21 times, while Hamilton gained time 28 times. However, the overall mean time gain per Pitstop for 2017 and 2018 respectively was 381 and 271 milliseconds in favor of Hamilton.\nIn 2019 and 2020 the Pitstops are a lot closer. Overall Bottas gained 49 milliseconds in 2019 and 79 milliseconds in 2020 on average.\nRed Bull is known for their fast Pitstops. This is represented by the data as well. In the 30 compared Pitstops Mercedes only beat Red Bull 9 times in 2021. On average Verstappen gained 268 milliseconds per Pitstop during that season.\nConclusion As mentioned at the start, the data should not be overinterpreted. Instead of drawing conclusions from this data, we looked at commonly known things in Formula 1, such as Red Bull\u0026rsquo;s strong Pitstops and Hamilton\u0026rsquo;s strong final phase, and looked if we could find these impressions in the data. Overall this was a fun way for me to refresh my SQL, Pandas, and ggplot knowledge.\n","permalink":"https://huti26.github.io/posts/formula-1/hamilton-vs-bottas/","summary":"Preface The 2021 season of Formula 1 is the first one I watched and I have been a fan of both Hamilton and Bottas ever since. During this season Bottas has been criticized a lot. That\u0026rsquo;s why I wanted to do a bit of data analysis on how Hamilton and Bottas compare in raw numbers. Raw numbers are not a particularly good way to make hard statements in Formula 1, since they lack a lot of context.","title":"Lewis Hamilton 2017-2021"},{"content":"Preface Flutter is first and foremost a Framework to create cross-platform applications, but it can also be used to create WebApps. Since I don\u0026rsquo;t have any experience with the three big Web Frameworks: VueJS, React, and Angular, I thought Flutter would be a good fit for me. It also uses Dart instead Javascript. My initial impression was, that this is also an improvement. Since I have not made any proper experiences with other Web Frameworks or Javascript, I won\u0026rsquo;t be able to compare those to Flutter/Dart in this article. However, I will still talk about my impressions as someone with very little experience in Frontend. My interest is in the Backend and in that regard, we will look at Firebase and how Flutter integrates with it.\nThe project is far from in a finished state and I have no intentions of actually finishing it. Visually it\u0026rsquo;s not particularly pretty, but it is decently functional. You can check it out yourself here.\nCode Structure The current code structure looks as follows.\n/lib\r│ generated_plugin_registrant.dart\r│ main.dart\r│\r├───Authentification\r│ auth.dart\r│\r├───Constants\r│ constants.dart\r│\r├───Database\r│ db_user.dart\r│\r├───Helper Functions\r│ navigation.dart\r│ numberformat.dart\r│ textfields.dart\r│\r├───Model\r│ food.dart\r│ meal.dart\r│ user.dart\r│\r├───Pages\r│ │ login.dart\r│ │ register.dart\r│ │ welcome.dart\r│ │\r│ └───Mealprep\r│ │ foods.dart\r│ │ home.dart\r│ │ settings.dart\r│ └───Settings\r│ change_activitylevel_page.dart\r│ change_age_page.dart\r│ change_goal_page.dart\r│ change_height_page.dart\r│ change_language_page.dart\r│ change_region_page.dart\r│ change_sex_page.dart\r│ change_weight_page.dart\r│ settings_card.dart\r│\r├───Providers\r│ currently_created_food.dart\r│ currently_created_meal.dart\r│\r└───Widgets\r└───Cards\rfood_card.dart The entrypoint to the app is main.dart. Further sites of the WebApp are found in the /Pages folder. To mirror our logic with dart classes we have the /Model folder. There we find the concepts of foods, meals, and users. Shared constants among the project are found in /Constants/constants.dart. Most of our interaction with the database and the authentication is bundled within the pages, but small shared parts are in their respective Database and Authentication folder. Reused Widgets are in the Widgets folder, but we put very little effort into the visual part of this project, so there is only one item inside that folder. The last and particularly interesting part is the /Providers folder. There we have two classes, which maintain shared state in our WebApp. A user can create new foods and meals and while doing so he visits multiple sites, which need to share a state.\nApp Walkthrough Now that we have seen the general code structure, we will have a walkthrough of the app and its functions. We will refer to the interesting code excerpts while doing so.\nLog In \u0026amp; Register The first page a user is greeted by is our not-so-pretty welcome screen, in which a user either logs in or registers.\nA nice detail the welcome screen implements is that a user stays logged in even after closing the site, unless of course, he manually logs out. So if a user is logged in already, the welcome screen will automatically refer him to the homepage of the app. This is done as follows.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @override void initState() { FirebaseAuth.instance.authStateChanges().listen((User user) async { if (user != null \u0026amp;\u0026amp; !attemptingToLogin) { attemptingToLogin = true; print(\u0026#34;Attempting to login\u0026#34;); if (!user.emailVerified) { setState(() { logedInButNotVerified = true; }); } else if (user.emailVerified) { print(\u0026#34;checking for user data\u0026#34;); await userReference.doc(\u0026#34;${user.uid}\u0026#34;).get().then((userSnapshot) async { if (userSnapshot.exists) { print(\u0026#34;user found\u0026#34;); } else { await createUserInFirestore(user.uid); } }).catchError((error) =\u0026gt; print(error)); print(\u0026#34;logged in verified user\u0026#34;); hardNavigate(context, MealprepTabContainer()); } } }); super.initState(); } If this is the first time looking at Flutter/Firebase code, this is a lot to swallow, so we will go over it one by one. First: the function initState(). I am far from a Flutter expert and will describe things in a simple way. If you are curious about details and intending to become a Flutter expert, I strongly suggest you check out the documentation. Simply put, this function is called when a stateful widget in Flutter is loaded. We won\u0026rsquo;t go into furth details on stateful and stateless widgets, but the general concept is easy to guess by the name. Some structures in Flutter maintain a state and some don\u0026rsquo;t. Inside our welcome page, we want to maintain a state, since we want to check, if a user is logged in or not. We do this, by listening to FirebaseAuth. This async function will notify us if the login status changes. Once that happens, we will also check, if our user\u0026rsquo;s email is verified. Our app only allows verified users to log in. If the user is verified, our helper function hardNavigate() is called and sends the user to the mentioned homepage of the app. We won\u0026rsquo;t go into any details on how navigation in Flutter works.\nThe login page looks as follows and supports resetting the user\u0026rsquo;s password.\nThe Flutter version I used, does not support browser autofilling credentials. Since I created this app more than a year ago, I hope they fixed this issue in the meantime.\nAll authentication here is also handled by FirebaseAuth. Additionally, we want to maintain further information on our users. Since this is a calorietracker, we need all sorts of information on our users, such as their age or their weight. So additionally to what FirebaseAuth stores, we create a user object, which we store inside our database Firestore. This exchange between database and dart code is an interesting detail. When we request a user object from the database, we get JSON data, which binds keys to values. Our keys are guaranteed to be strings, while our values might be anything. To create a user object in dart from given data we use the following code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 MealprepUser.fromMap(Map\u0026lt;String, dynamic\u0026gt; data) { uid = data[\u0026#34;uid\u0026#34;]; name = data[\u0026#34;name\u0026#34;]; age = data[\u0026#34;age\u0026#34;]; height = data[\u0026#34;height\u0026#34;]; weight = data[\u0026#34;weight\u0026#34;]; sex = data[\u0026#34;sex\u0026#34;]; goal = data[\u0026#34;goal\u0026#34;]; bmr = data[\u0026#34;bmr\u0026#34;]; caloriegoal = data[\u0026#34;caloriegoal\u0026#34;]; activitylevel = data[\u0026#34;activitylevel\u0026#34;]; language = data[\u0026#34;language\u0026#34;]; region = data[\u0026#34;region\u0026#34;]; } In dart, we can create Maps with elements of a dynamic type. In this case, it is rather boring, since all the dynamic types are either strings or numbers. The meal class is more exciting.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Meal.fromMap(Map\u0026lt;String, dynamic\u0026gt; data) { name = data[\u0026#34;name\u0026#34;]; description = data[\u0026#34;description\u0026#34;]; submitterUID = data[\u0026#34;submitterUID\u0026#34;]; calories = data[\u0026#34;calories\u0026#34;]; carbs = data[\u0026#34;carbs\u0026#34;]; proteins = data[\u0026#34;proteins\u0026#34;]; fats = data[\u0026#34;fats\u0026#34;]; price = data[\u0026#34;price\u0026#34;]; priceonsale = data[\u0026#34;priceonsale\u0026#34;]; public = data[\u0026#34;public\u0026#34;]; List\u0026lt;dynamic\u0026gt; foodList = data[\u0026#34;foods\u0026#34;]; foodList.forEach((element) { foods.add(Food.fromMap(element)); }); } Starting with line 13 we add load food as JSON data from the database, create dart objects of it and add those to our meal.\nBefore this project, I have been taking part in the Stanford online course cs193p, which teaches Swift and SwiftUI. A feature I missed here from Swift is computed properties. In Swift, one can create variables which instead of storing a value, provide a getter and setter function. This would come in handy to automatically update the meal\u0026rsquo;s properties such as its total calorie count, whenever the object changes. This happens, when a user for example adds a new food to a meal. Instead, we have to manually call the following function, every time we change our meals.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 updateFields() { calories = 0; carbs = 0; proteins = 0; fats = 0; price = 0; priceonsale = 0; foods.forEach((food) { calories += food.calories; carbs += food.carbs; proteins += food.proteins; fats += food.fats; price += food.packageprice; priceonsale += food.packagepricesale; }); } Foods \u0026amp; Meals Once logged in, the user is greeted by a typical mobile app design. Of all the 4 tabs, only the settings one is useful. The user can change his goals and body measurements there.\nIf the user presses the + button in the middle, he can either create a new food or a new meal.\nWe will look at the food creation to understand the provider class.\nThe food creation consists of 4 pages. These pages simply contain forms, which the user has to fill out. Calories, price, and the name of the food are to be inserted among other things.\nThis form looks as follows in Flutter.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(), body: Form( key: formKey, child: Padding( padding: const EdgeInsets.all(generalPadding), child: Column( children: [ NumberTextField(\u0026#34;Barcode\u0026#34;, eanController), StringTextFieldRequired(\u0026#34;Name*\u0026#34;, nameController), StringTextField(\u0026#34;Brand\u0026#34;, brandController), RaisedButton( child: Text(\u0026#34;Continue\u0026#34;), onPressed: () { validateAndContinue(); }, ), ], ), ), ), ); } Inside a scaffold, we have a Form consisting of a Column with 4 children: 3 TextFields and 1 Button. When the button is pressed the validateAndContinue() function is called. Here our provider class is finally used. First, let\u0026rsquo;s look at our provider class itself.\n1 2 3 4 5 6 7 class CurrentlyCreatedFood extends ChangeNotifier{ Food food = Food.empty(); bool filledPage1 = false; bool filledPage2 = false; bool filledPage3 = false; } It is very simple, we have a food object and 3 boolean values, which indicate, whether we have already filled a page. Next, we look at how we use this provider class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 validateAndContinue() { if (formKey.currentState.validate()) { var currentFoodProvider = Provider.of\u0026lt;CurrentlyCreatedFood\u0026gt;(context,listen: false); var currentFood = currentFoodProvider.food; currentFood.ean = eanController.text; currentFood.name = nameController.text; currentFood.brand = brandController.text; currentFoodProvider.filledPage1 = true; softNavigate(context, MealprepCreateFoodPage2()); } } Validation is done by Flutter itself, it only verifies that we have numbers in our NumberTextField and text in our StringTextField. Then, we access the currently created food object through this provider class. Next, the user will be navigated to page 2 out of 4.\nLet\u0026rsquo;s assume the user made a typo and returns to page 1 now. We don\u0026rsquo;t want to force the user to retype all values. To achieve that, we use the provider shared state again, this time in our initState() function.\n1 2 3 4 5 6 7 8 9 10 11 12 13 @override void initState() { var currentFoodProvider = Provider.of\u0026lt;CurrentlyCreatedFood\u0026gt;(context,listen: false); var currentFood = Provider.of\u0026lt;CurrentlyCreatedFood\u0026gt;(context,listen: false).food; if(currentFoodProvider.filledPage1){ eanController.text = currentFood.ean; nameController.text = currentFood.name; brandController.text = currentFood.brand; } super.initState(); } Our provider class keeps track of which pages we have already filled out. If we return to page 1, the TextFields will be filled out in this way.\nNow if the user reaches page 4 he will be able to submit the food to the database. The code for that looks as follows.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 submitFood() async { var currentFoodProvider = Provider.of\u0026lt;CurrentlyCreatedFood\u0026gt;(context,listen: false); var currentFood = Provider.of\u0026lt;CurrentlyCreatedFood\u0026gt;(context,listen: false).food; // set final meta data, things that user doesnt input var documentSnapshot = await usersReference.doc(\u0026#34;$authUID\u0026#34;).get(); var user = MealprepUser.fromMap(documentSnapshot.data()); currentFood.submitterUID = authUID; currentFood.region = user.region; var currentFoodAsMap = currentFood.toMap(); FirebaseFirestore.instance .collection(\u0026#34;foods\u0026#34;) .add(currentFoodAsMap) .then((value) { hardNavigate(context, MealprepTabContainer()); // reset food currentFoodProvider.filledPage1 = false; currentFoodProvider.filledPage2 = false; currentFoodProvider.filledPage3 = false; currentFood = Food.empty(); Fluttertoast.showToast( msg: \u0026#34;Successfully added the Food.\u0026#34;, toastLength: Toast.LENGTH_LONG); }).catchError((error) { Fluttertoast.showToast( msg: \u0026#34;Could not add the Food. Something went wrong.\u0026#34;, toastLength: Toast.LENGTH_LONG); }); } First, we access the food object through the provider again. Then we will add some metadata to the food object. Finally, the object can be submitted to the database. For that, we convert our object to JSON data with currentFood.toMap(). Then in the case of a successful submission, we send the user a little feedback in the form of a toast. In the case of an error, we also inform the user appropriately.\nCreating a meal is logically very similar.\nOn the left side, there is a list of all available foods. On the right side, there is a list of already added foods. The user can track the total meal price and calories while adding foods. If now the user wants to add Rigatoni, but not 500g, which is the default package size, he can click the item, and a modal opens.\nNot particularly pretty, but it gets the job done. If the user presses done, the updated package size, here 250g, will be added to the meal.\nIf the user is done, he can submit the meal to the database. The user may also choose if the meal is visible to others with the public toggle. The same applies to foods.\nConclusion From a technical point of view, there are two interesting parts: Flutter and Firebase. Regarding Flutter, I have been very happy with the resources available online. The code structure and concepts are very intuitive. However, I am not able to compare Flutter to other Cross-Platform Frameworks or Web Frameworks. Working with Firebase was also very intuitive. The Firebase Authentication service is well documented and easily integrates into Flutter Apps. Firestore, the Firebase Database, provides 50.000 free reads, 20.000 free writes, and 20.000 free deletes per day. For a hobby project, this is more than plenty. Functionality wise it also provides everything you would expect from a document-oriented database. I have not worked with a database as a service before and can only compare my experience to working with for example self-hosted RocksDB or a typical SQL database such as MySQL or SQLite. The fact, that you don\u0026rsquo;t have to worry about the hardware, on which the database runs, is of course comfortable. However, for a big project, I would be cautious concerning the costs. Changing from one NoSQL database to another can be a difficult process. I would spend a fair amount of time researching which database to use.\nThe second part of this project is the actual content. A calorietracker is of course nothing new. There are plenty of great ones out there already. One feature I am personally missing from them is more statistics! I would love to have something like the Spotify yearly review but for my nutrition. Also, the calorietrackers don\u0026rsquo;t track the costs of the foods consumed. I would love to have that available too. I will not continue the development of this app. While in theory, it should be easy to add missing features and port this app to iOS and Android, Making it a real product and competing with established solutions, which already have a strong userbase and plenty of items in their database seems unrealistic. Rather, I would love to have one of the established apps add some more statistics.\n","permalink":"https://huti26.github.io/posts/flutter-calorietracker/flutter-calorietracker/","summary":"Preface Flutter is first and foremost a Framework to create cross-platform applications, but it can also be used to create WebApps. Since I don\u0026rsquo;t have any experience with the three big Web Frameworks: VueJS, React, and Angular, I thought Flutter would be a good fit for me. It also uses Dart instead Javascript. My initial impression was, that this is also an improvement. Since I have not made any proper experiences with other Web Frameworks or Javascript, I won\u0026rsquo;t be able to compare those to Flutter/Dart in this article.","title":"Building a Calorietracker WebApp with Flutter and Firebase"}]